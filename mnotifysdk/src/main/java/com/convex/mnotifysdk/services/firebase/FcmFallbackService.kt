package com.convex.mnotifysdk.services.firebase

import android.content.Intent
import android.content.pm.PackageManager
import android.util.Log
import com.convex.mnotifysdk.MNotifyApp
import com.convex.mnotifysdk.config.GeneratedConfig
import com.convex.mnotifysdk.model.NotificationModel
import com.convex.mnotifysdk.notification.NotificationsManager
import com.convex.mnotifysdk.services.MNotifyMessagingService
import com.convex.mnotifysdk.services.SocketService
import com.convex.mnotifysdk.utils.PrefsHelper
import com.google.firebase.messaging.FirebaseMessagingService
import com.google.firebase.messaging.RemoteMessage
import com.google.gson.Gson
import org.json.JSONObject
import kotlin.jvm.java
import kotlin.toString


internal class FcmFallbackService : FirebaseMessagingService() {

    override fun onMessageReceived(msg: RemoteMessage) {
        // Two behaviors:
        // 1) Deliver remote notification (optional, app-defined)
        // 2) “Kick” the custom service (fallback revive)

        val full_data = msg
        val data = msg.data
        Log.i("FCM_TOKEN","onMessageReceived DATA: ${data}")
        when (data["type"]) {
            "ping" -> {
                // ✅ Silent ping: restart/revive PersistentMessagingService
//                val serviceIntent = Intent(this, PersistentMessagingService::class.java)
                val serviceIntent = Intent(applicationContext, SocketService::class.java)
                val config_json = PrefsHelper.getConfig(applicationContext)
//                BNotifyApp.initialize(applicationContext,serviceIntent,BNotifyApp.getActivityToOpenOnClick(applicationContext), config_json.toString())
                MNotifyApp.initializeBase(
                    applicationContext,
                    MNotifyApp.getActivityToOpenOnClick(applicationContext),
                    GeneratedConfig.JSON.toString()
                )
//                val myServiceIntent = Intent(this, MyMessagingService::class.java)

                startService(serviceIntent)
//                startService(myServiceIntent)
//                applicationContext.restartConsumerService(MyMessagingService::class.java)
//                stopSelf()
                // also restart consumer service
//                restartConsumerService()
                Log.d("FCM_FALLBACK", "Ping received, service restarted")
            }
            else -> {
                // Handle normal notification (optional)
                // If there’s a user-visible notification payload and the app wants to show it:
                val title = data["title"] ?: "New message"
                val body = data["body"] ?: "You have a new message"
                Log.i("FCM_TOKEN","onMessageReceived ${data}")


                val jsonObject = JSONObject()
                for ((key, value) in data) {
                    jsonObject.put(key, value)
                }
                Log.d("NOTIFY_MESSAGE_DATA", "FCM FULL MESSAGE: ${full_data}")
                Log.d("NOTIFY_MESSAGE_DATA", "FCM MESSAGE: ${jsonObject.toString()}")

                val model: NotificationModel = Gson().fromJson(jsonObject.toString(), NotificationModel::class.java)
                NotificationsManager.init(this)
                if(MNotifyApp.getIsAutoGeneratedNotification(applicationContext)){
                    NotificationsManager.handleNow(model, applicationContext)
                }else{
                    MNotifyApp.getNotificationListener()?.onMessageReceive(model)
                }
            }
        }

    }

    override fun onNewToken(token: String) {
        // Forward to your server so it can send FCM fallback pings
//        ExternalPushConnectorHolder.get()?.onNewFcmToken(token)
        Log.i("FCM_TOKEN","${token}")
    }

    private fun restartConsumerService() {
        try {
            val pm = packageManager
            val pkgName = packageName

            // Query all services declared in this app’s manifest
            val services = pm.getPackageInfo(pkgName, PackageManager.GET_SERVICES).services
            if (services != null) {
                for (svc in services) {
                    try {
                        val clazz = Class.forName(svc.name)
                        if (MNotifyMessagingService::class.java.isAssignableFrom(clazz)) {
                            // Found consumer subclass!
                            val intent = Intent(this, clazz)
                            startService(intent)
                            Log.d("FCM_FALLBACK", "Consumer BnotifyMessagingService restarted: ${clazz.name}")
                            return
                        }
                    } catch (cnfe: ClassNotFoundException) {
                        // ignore and continue
                        Log.e("FCM_FALLBACK", "Failed to ClassNotFoundException: ${cnfe.message}", cnfe)
                    }
                }
            }
            Log.w("FCM_FALLBACK", "No BnotifyMessagingService subclass found in manifest")
        } catch (t: Throwable) {
            Log.e("FCM_FALLBACK", "Failed to restart consumer service: ${t.message}", t)
        }
    }
}