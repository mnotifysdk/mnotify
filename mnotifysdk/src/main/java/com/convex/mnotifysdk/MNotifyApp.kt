package com.convex.mnotifysdk

import android.Manifest
import android.app.Activity
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.util.Log
import androidx.annotation.NonNull
import androidx.core.content.ContextCompat
import com.convex.mnotifysdk.activity.PermissionRequestActivity
import com.convex.mnotifysdk.model.BnotifyConfig
import com.convex.mnotifysdk.model.NotificationModel
import com.convex.mnotifysdk.receiver.NotificationDismissReceiver
import com.convex.mnotifysdk.services.firebase.FirebaseManual
import com.convex.mnotifysdk.socket.SocketManager
import com.convex.mnotifysdk.utils.NotifyConstants
import com.convex.mnotifysdk.utils.PrefsHelper
import com.google.android.gms.tasks.OnCompleteListener
import com.google.android.gms.tasks.Task
import com.google.firebase.messaging.FirebaseMessaging
import org.json.JSONObject
import kotlin.apply
import kotlin.jvm.java
import kotlin.text.toIntOrNull
import kotlin.toString

object MNotifyApp {
    private const val PERMISSION_REQUEST_CODE = 1001
    private var activityClass: Class<out Activity>? = null

    private var notification_listener:OnNotificationListener? = null
    private var token_listener: OnTokenListener? = null

    private var isAutoGeneratedNotification = true;
    private var isInitialized = false

    private fun initialize(context: Context,intent: Intent, activity: Class<out Activity>, json: String){
        PrefsHelper.saveConfig(context, json)
        val config_json = PrefsHelper.getConfig(context)
        var configs: BnotifyConfig = readBNotifyConfig(config_json.toString())!!
        FirebaseManual.initialize(context, configs)
        FirebaseMessaging.getInstance().getToken()
            .addOnCompleteListener(object : OnCompleteListener<String?> {
                override fun onComplete(@NonNull task: Task<String?>) {
                    if (!task.isSuccessful()) {
                        Log.w("SocketManager", "Fetching FCM registration token failed", task.getException())
                        return
                    }

                    // Get new FCM registration token
                    val token = task.getResult()
                    if (token != null) {
                        PrefsHelper.saveFcmToken(context.applicationContext, token)
                        SocketManager.FCM_TOKEN = token
                    }
                    // Log and toast
                    Log.i("SocketManager", "FCM onComplete ${token}")
                    setActivityToOpenOnClick(activity)
//                    if (!RunFCMOnly()){
//                        startPersistentService(context)
////                    scheduleAlarmManager(context)
//                        scheduleSocketMonitor(context)
//                    }else{
//                        SocketManager.initialize(context.applicationContext)
//                        SocketManager.connect()
//                    }
                    SocketManager.initialize(context.applicationContext)
                    SocketManager.connect()
                    notificationInitializer(context,intent)
                    context.restartConsumerService(intent)
                }
            })
    }

    /**
     * Step 1: Base initialization (Application.onCreate).
     * No Intent is passed here.
     */
    fun initializeBase(context: Context, activity: Class<out Activity>, json: String) {
        if (isInitialized) return

        PrefsHelper.saveConfig(context, json)
        setActivityToOpenOnClick(activity)

        val configJson = PrefsHelper.getConfig(context)
        val configs: BnotifyConfig = readBNotifyConfig(configJson.toString())!!

        // Firebase manual init
        FirebaseManual.initialize(context, configs)

        // Get FCM token and init socket
        FirebaseMessaging.getInstance().getToken()
            .addOnCompleteListener(object : OnCompleteListener<String?> {
                override fun onComplete(@NonNull task: Task<String?>) {
                    if (!task.isSuccessful) {
                        Log.w("BNotifyApp", "Fetching FCM registration token failed", task.exception)
                        return
                    }

                    val token = task.result
                    if (token != null) {
                        PrefsHelper.saveFcmToken(context.applicationContext, token)
                        SocketManager.FCM_TOKEN = token
                    }

                    Log.i("BNotifyApp", "FCM token: $token")

                    SocketManager.initialize(context.applicationContext)
                    SocketManager.connect()
                }
            })

        isInitialized = true
        Log.i("BNotifyApp", "Base initialization complete")
    }

    /**
     * Step 2: Handle runtime Intent (Activity.onCreate / onNewIntent).
     */
    fun handleIntent(context: Context, intent: Intent?) {
        if (intent == null) {
            Log.i("BNotifyApp", "No intent passed to handleIntent()")
            return
        }

        notificationInitializer(context, intent)
        context.restartConsumerService(intent)
    }

    fun setIsAutoGeneratedNotification(context: Context, enable: Boolean){
        isAutoGeneratedNotification = enable
        PrefsHelper.saveAutoGeneratedNotification(context, isAutoGeneratedNotification)
    }

    internal fun readBNotifyConfig(json: String): BnotifyConfig? {
//        val json = GeneratedConfig.JSON ?: return null // safe null check
        return try {
            val jsonObject = JSONObject(json)
            Log.i("Bnotify", "Extracted DATA: $json")

            BnotifyConfig(
                projectId = jsonObject.optString("projectId"),
                packageName = jsonObject.optString("packageName"),
                apiKey = jsonObject.optString("apiKey"),
                authDomain = jsonObject.optString("authDomain"),
                databaseURL = jsonObject.optString("databaseURL"),
                storageBucket = jsonObject.optString("storageBucket"),
                messagingSenderId = jsonObject.optString("messagingSenderId"),
                appId = jsonObject.optString("appId"),
                measurementId = jsonObject.optString("measurementId"),
                fcmAppId = jsonObject.optString("fcmAppId"),
                fcmProjectId = jsonObject.optString("fcmProjectId"),
                fcmApiKey = jsonObject.optString("fcmApiKey"),
                fcmSenderId = jsonObject.optString("fcmSenderId")
            )
        } catch (e: Exception) {
            Log.e("Bnotify", "Failed to parse config: ${e.message}")
            null
        }
    }

    internal fun getIsAutoGeneratedNotification(context: Context): Boolean{
        isAutoGeneratedNotification = PrefsHelper.isAutoGeneratedNotification(context)!!
        return isAutoGeneratedNotification
    }

    fun setActivityToOpenOnClick(activity: Class<out Activity>){
        this.activityClass = activity
    }

    internal fun getActivityToOpenOnClick(context: Context): Class<out Activity> {
        return activityClass
            ?: context.getLauncherActivityClass()
            ?: throw kotlin.IllegalStateException("No launcher activity found in manifest")
    }

    fun setNotificationListener(listener: OnNotificationListener){
        this.notification_listener = listener
    }

    internal fun getNotificationListener(): OnNotificationListener? {
        return this.notification_listener
    }

    fun setOnTokenListener(listener: OnTokenListener){
        this.token_listener = listener
    }

    internal fun getTokenListener(): OnTokenListener? {
        return this.token_listener
    }

    internal fun notificationInitializer(activityContext: Context,intent: Intent) {
        if (ContextCompat.checkSelfPermission(
                activityContext,
                Manifest.permission.POST_NOTIFICATIONS
            ) == PackageManager.PERMISSION_GRANTED
        ) {
//            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
//                checkAndRequestExactAlarmPermission(activityContext)
//            }

            if (intent.extras != null){
                val action = intent.getStringExtra(NotifyConstants.ACTION)
                val type = intent.getStringExtra(NotifyConstants.TYPE)
                val screen = intent.getStringExtra(NotifyConstants.SCREEN)
                val notification_id = intent.getStringExtra(NotifyConstants.NOTIFICATION_ID)
                val token = intent.getStringExtra(NotifyConstants.TOKEN)

                Log.i("Notification_SocketIO", "CLICKED Notification ID: $notification_id ACTION: $action TYPE: $type")
                val receiverIntent = Intent(activityContext, NotificationDismissReceiver::class.java).apply {
                    putExtra(NotifyConstants.NOTIFICATION_ID, notification_id ?: 0)
                    putExtra(
                        NotifyConstants.ACTION,
                        NotifyConstants.ClickedEvent
                    ) // Action when dismissed
                    putExtra(NotifyConstants.TYPE, type ?: null)
                    putExtra(NotifyConstants.SCREEN, screen)
                    putExtra(NotifyConstants.CLICK, true)
                    putExtra(NotifyConstants.TOKEN, token)
                }
                activityContext.sendBroadcast(receiverIntent)
            }else{
                Log.i("Notification_SocketIO", "No notification data")
            }
        } else {
            // Start permission activity
            val intent = Intent(activityContext, PermissionRequestActivity::class.java).apply {
                flags = Intent.FLAG_ACTIVITY_NEW_TASK
                putExtra(
                    "request_code",
                    PERMISSION_REQUEST_CODE
                )
            }
            activityContext.startActivity(intent)
        }

    }


    private fun Context.getLauncherActivityClass(): Class<out Activity>? {
        val pm = packageManager
        val launchIntent = pm.getLaunchIntentForPackage(packageName) ?: return null
        val component = launchIntent.component ?: return null

        return try {
            Class.forName(component.className) as Class<out Activity>
        } catch (e: ClassNotFoundException) {
            null
        }
    }

    internal fun Context.restartConsumerService(intent: Intent){
        startService(intent)
    }

    fun setOnNotificationReceived(model: NotificationModel){
        if (SocketManager.isConnected()){
            SocketManager.handleNotificationReceived(model)
        }
    }

    fun setOnNotificationDismissed(context: Context, pendingIntentFlags:Int, model: NotificationModel): PendingIntent{
        val dismissIntent = Intent(context, NotificationDismissReceiver::class.java).apply {
            putExtra(NotifyConstants.NOTIFICATION_ID, model.notificationId ?: 0)
            putExtra(
                NotifyConstants.ACTION,
                NotifyConstants.DismissedEvent
            ) // Action when dismissed
            putExtra(NotifyConstants.TYPE, model.type ?: null)
            putExtra(NotifyConstants.CLICK, false)
            putExtra(NotifyConstants.TOKEN, model.token)
        }

        val dismissPendingIntent = PendingIntent.getBroadcast(
            context,
            (model.notificationId?.toIntOrNull() ?: System.currentTimeMillis().toInt()) + 1, // Different request code
            dismissIntent,
            pendingIntentFlags
        )

        if (SocketManager.isConnected()){
            SocketManager.handleNotificationDismissedIntent(dismissIntent)
        }

        return dismissPendingIntent
    }

    fun setOnNotificationClicked(context: Context,intent: Intent){
        Log.d("Notification_SocketIO", "Notification Click: event: BNotifyApp Class")
        if (SocketManager.isConnected()){
            /*            if (intent.extras!=null){
                            val action = intent.getStringExtra("action")
                            val click = intent.getBooleanExtra("click", false)
                            val notificationId = intent.getStringExtra("notification_id")
                            Log.d("Notification_SocketIO", "Notification ID: $notificationId ACTION: $action CLICKED: $click")
                            if (click){
                                SocketManager.handleNotificationClickedIntent(intent)
                            }
                        }*/

            if (intent.extras != null){
                val action = intent.getStringExtra(NotifyConstants.ACTION)
                val type = intent.getStringExtra(NotifyConstants.TYPE)
                val screen = intent.getStringExtra(NotifyConstants.SCREEN)
                val notification_id = intent.getStringExtra(NotifyConstants.NOTIFICATION_ID)

                Log.i("Notification_SocketIO", "CLICKED Notification ID: $notification_id ACTION: $action TYPE: $type")
                val receiverIntent = Intent(context, NotificationDismissReceiver::class.java).apply {
                    putExtra(NotifyConstants.NOTIFICATION_ID, notification_id ?: 0)
                    putExtra(
                        NotifyConstants.ACTION,
                        NotifyConstants.ClickedEvent
                    ) // Action when dismissed
                    putExtra(NotifyConstants.TYPE, type ?: null)
                    putExtra(NotifyConstants.SCREEN, screen ?: null)
                    putExtra(NotifyConstants.CLICK, true)
                    Log.d("Notification_SocketIO", "Notification ID: $notification_id ACTION: $action CLICKED: true")
                }
                context.sendBroadcast(receiverIntent)
            }else{
                Log.i("Notification_SocketIO", "No notification data found On Click")
            }
        }
    }

    interface OnNotificationListener{
        fun onMessageReceive(remoteMessage: NotificationModel?)
    }

    interface OnTokenListener{
        fun onNewToken(token: String?)
    }
}